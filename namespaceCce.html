<!-- HTML header for doxygen 1.8.10-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="author" content="SXS Collaboration">
    <meta name="generator" content="Doxygen 1.8.13"/>
    <style>
        /*!
         * IE10 viewport hack for Surface/desktop Windows 8 bug
         * Copyright 2014-2015 Twitter, Inc.
         * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
         */
        @-webkit-viewport { width: device-width; }
        @-moz-viewport    { width: device-width; }
        @-ms-viewport     { width: device-width; }
        @-o-viewport      { width: device-width; }
        @viewport         { width: device-width; }
      </style>
  <title>SpECTRE: Cce Namespace Reference</title>
  <link href="tabs.css" rel="stylesheet" type="text/css"/>
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="dynsections.js"></script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
  <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js", "color.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
MathJax.Hub.Config({
    TeX: { equationNumbers: { autoNumber: "AMS" } }
});
MathJax.Hub.Config({
    tex2jax: {inlineMath: [['^^','^^'], ['\\(', '\\)']]}
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js"></script>
  <link href="octicons.css" rel="stylesheet">
  <link href="bootstrap.min.css" rel="stylesheet">
  <link href="doxygen.css" rel="stylesheet" type="text/css" />
  <script type="text/javascript" src="jquery.js"></script>
  <script type="text/javascript" src="popper.min.js"></script>
  <script type="text/javascript" src="bootstrap.min.js"></script>
  <script type="text/javascript" src="spectre.js"></script>
  </head>
  <body>
  <div id="top" class="navbar-fixed-top"><!-- do not remove this div, it is closed by doxygen! -->
  <!-- BEGIN TITLEAREA -->
  <div id="titlearea">
  <script type="text/javascript">
  var searchBox = new SearchBox("searchBox", "search",false,'Search');
  </script>
  <div id="main-nav">
    <ul class="sm sm-dox" id="main-menu">
      <li>
      <a href="index.html">
      SpECTRE &#160;
        <span id="projectnumber">v0.0.0</span>
      </a>
      </li>
      <li class="dropdown">
        <a class="dropdown-toggle" data-toggle="dropdown" href="#" id="selected">
          <span id="selected">
            <i class="octicon octicon-book"></i><span>Documentation</span>
          </span>
          <span class="caret"></span>
        </a>
        <ul class="dropdown-menu">
          <li style="min-width: 135px;">
            <a href="index.html">
            <i class="octicon octicon-book"></i><span>Introduction</span></a>
          </li>
          <li style="min-width: 135px;">
            <a href="installation.html">
              <i class="octicon octicon-desktop-download"></i><span>Installation</span>
            </a>
          </li>
          <li style="min-width: 135px;">
            <a href="tutorials.html">
              <i class="octicon octicon-mortar-board"></i><span>User Tutorials</span>
            </a>
          </li>
          <li style="min-width: 135px;">
            <a href="dev_guide.html">
              <i class="octicon octicon-gist-secret"></i><span>Dev Guide</span>
            </a>
          </li>
          <li style="min-width: 135px;">
            <a href="code_of_conduct.html">
              <i class="octicon octicon-comment-discussion"></i><span>Code of Conduct</span>
            </a>
          </li>
          <li style="min-width: 135px;">
            <a href="contributing_to_spectre.html">
              <i class="octicon octicon-git-pull-request"></i><span>Contributing Guide</span>
            </a>
          </li>
        </ul>
      </li>
      <li class="dropdown">
        <a class="dropdown-toggle" data-toggle="dropdown" href="#" id="selected">
          <span id="selected">
            <i class="octicon octicon-code"></i>
              <span>Code Reference</span>
          </span>
          <span class="caret"></span>
        </a>
        <ul class="dropdown-menu">
          <li style="min-width: 130px;">
            <a href="modules.html">
              <i class="octicon octicon-code"></i>
              <span>Topics</span>
            </a>
          </li>
          <li style="min-width: 130px;">
            <a href="namespaces.html">
              <i class="octicon octicon-gist"></i>
              <span>Namespaces</span>
            </a>
          </li>
        </ul>
      </li>
      <li>
        <a href="files.html">
          <i class="octicon octicon-file-directory"></i><span>Files</span>
        </a>
      </li>
      <li>
        <a href="citelist.html">
          <i class="octicon octicon-file-text"></i><span>Bibliography</span>
        </a>
      </li>
      <li>
        <a href="https://github.com/sxs-collaboration/spectre" target="_blank">
          <i class="octicon octicon-mark-github"></i><span>View on GitHub</span>
        </a>
      </li>
      <!--The Search <li> is added by doxygen later-->
    </ul>
  </div><!-- main-nav -->
  </div><!-- titlearea -->
  <!-- window showing the filter options -->
  <div id="MSearchSelectWindow"  style="position: fixed;"
       onmouseover="return searchBox.OnSearchSelectShow()"
       onmouseout="return searchBox.OnSearchSelectHide()"
       onkeydown="return searchBox.OnSearchSelectKey(event)">
  </div>
  <!-- iframe showing the search results (closed by default) -->
  <div id="MSearchResultsWindow"  style="position: fixed;">
  <iframe src="javascript:void(0)" frameborder="0"
          name="MSearchResults" id="MSearchResults">
  </iframe>
  </div>
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Cce Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Contains functionality for Cauchy Characteristic Extraction.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceCce_1_1Tags"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCce_1_1Tags.html">Tags</a></td></tr>
<tr class="memdesc:namespaceCce_1_1Tags"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespaceCce_1_1Tags.html" title="Tags for Cauchy Characteristic Extraction routines. ">Tags</a> for Cauchy Characteristic Extraction routines. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1ApplySwshJacobianInplace.html">ApplySwshJacobianInplace</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a mutation to a spin-weighted spherical harmonic derivative value from the numerical coordinate (the spin-weighted derivative at fixed \(y\)) to the Bondi coordinates (the spin-weighted derivative at fixed \(r\)), inplace to the requested tag.  <a href="structCce_1_1ApplySwshJacobianInplace.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1ApplySwshJacobianInplace_3_01Spectral_1_1Swsh_1_1Tags_1_1Derivative_3_01ArgumentTage51d3e9b700228a20725d336c7cc944d.html">ApplySwshJacobianInplace&lt; Spectral::Swsh::Tags::Derivative&lt; ArgumentTag, Spectral::Swsh::Tags::Eth &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for the spin-weighted derivative \(\eth\).  <a href="structCce_1_1ApplySwshJacobianInplace_3_01Spectral_1_1Swsh_1_1Tags_1_1Derivative_3_01ArgumentTage51d3e9b700228a20725d336c7cc944d.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1ApplySwshJacobianInplace_3_01Spectral_1_1Swsh_1_1Tags_1_1Derivative_3_01ArgumentTag902c2fcc05e24b3dacb792bbd112b8d3.html">ApplySwshJacobianInplace&lt; Spectral::Swsh::Tags::Derivative&lt; ArgumentTag, Spectral::Swsh::Tags::Ethbar &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for the spin-weighted derivative \(\bar{\eth}\).  <a href="structCce_1_1ApplySwshJacobianInplace_3_01Spectral_1_1Swsh_1_1Tags_1_1Derivative_3_01ArgumentTag902c2fcc05e24b3dacb792bbd112b8d3.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1ApplySwshJacobianInplace_3_01Spectral_1_1Swsh_1_1Tags_1_1Derivative_3_01ArgumentTag26ff3056ab474656d9f964b3753ed316.html">ApplySwshJacobianInplace&lt; Spectral::Swsh::Tags::Derivative&lt; ArgumentTag, Spectral::Swsh::Tags::EthbarEth &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for the spin-weighted derivative \(\bar{\eth} \eth\).  <a href="structCce_1_1ApplySwshJacobianInplace_3_01Spectral_1_1Swsh_1_1Tags_1_1Derivative_3_01ArgumentTag26ff3056ab474656d9f964b3753ed316.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1ApplySwshJacobianInplace_3_01Spectral_1_1Swsh_1_1Tags_1_1Derivative_3_01ArgumentTag859aa457f41c680db2a89b63b27b73c4.html">ApplySwshJacobianInplace&lt; Spectral::Swsh::Tags::Derivative&lt; ArgumentTag, Spectral::Swsh::Tags::EthbarEthbar &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for the spin-weighted derivative \(\bar{\eth} \bar{\eth}\).  <a href="structCce_1_1ApplySwshJacobianInplace_3_01Spectral_1_1Swsh_1_1Tags_1_1Derivative_3_01ArgumentTag859aa457f41c680db2a89b63b27b73c4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1ApplySwshJacobianInplace_3_01Spectral_1_1Swsh_1_1Tags_1_1Derivative_3_01ArgumentTag984be51c54c04d4877afc39da0746165.html">ApplySwshJacobianInplace&lt; Spectral::Swsh::Tags::Derivative&lt; ArgumentTag, Spectral::Swsh::Tags::EthEth &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for the spin-weighted derivative \(\eth \eth\).  <a href="structCce_1_1ApplySwshJacobianInplace_3_01Spectral_1_1Swsh_1_1Tags_1_1Derivative_3_01ArgumentTag984be51c54c04d4877afc39da0746165.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1ApplySwshJacobianInplace_3_01Spectral_1_1Swsh_1_1Tags_1_1Derivative_3_01ArgumentTagde52d8f01d670e4258ec54c545dae50a.html">ApplySwshJacobianInplace&lt; Spectral::Swsh::Tags::Derivative&lt; ArgumentTag, Spectral::Swsh::Tags::EthEthbar &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for the spin-weighted derivative \(\eth \bar{\eth}\).  <a href="structCce_1_1ApplySwshJacobianInplace_3_01Spectral_1_1Swsh_1_1Tags_1_1Derivative_3_01ArgumentTagde52d8f01d670e4258ec54c545dae50a.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1ComputeBondiIntegrand.html">ComputeBondiIntegrand</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes one of the inputs for the integration of one of the Characteristic hypersurface equations.  <a href="structCce_1_1ComputeBondiIntegrand.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1ComputeBondiIntegrand_3_01Tags_1_1Integrand_3_01Tags_1_1BondiBeta_01_4_01_4.html">ComputeBondiIntegrand&lt; Tags::Integrand&lt; Tags::BondiBeta &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the integrand (right-hand side) of the equation which determines the radial (y) dependence of the Bondi quantity \(\beta\).  <a href="structCce_1_1ComputeBondiIntegrand_3_01Tags_1_1Integrand_3_01Tags_1_1BondiBeta_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1ComputeBondiIntegrand_3_01Tags_1_1Integrand_3_01Tags_1_1BondiU_01_4_01_4.html">ComputeBondiIntegrand&lt; Tags::Integrand&lt; Tags::BondiU &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the integrand (right-hand side) of the equation which determines the radial (y) dependence of the Bondi quantity \(U\).  <a href="structCce_1_1ComputeBondiIntegrand_3_01Tags_1_1Integrand_3_01Tags_1_1BondiU_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1ComputeBondiIntegrand_3_01Tags_1_1LinearFactor_3_01Tags_1_1BondiH_01_4_01_4.html">ComputeBondiIntegrand&lt; Tags::LinearFactor&lt; Tags::BondiH &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the linear factor which multiplies \(H\) in the equation which determines the radial (y) dependence of the Bondi quantity \(H\).  <a href="structCce_1_1ComputeBondiIntegrand_3_01Tags_1_1LinearFactor_3_01Tags_1_1BondiH_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1ComputeBondiIntegrand_3_01Tags_1_1LinearFactorForConjugate_3_01Tags_1_1BondiH_01_4_01_4.html">ComputeBondiIntegrand&lt; Tags::LinearFactorForConjugate&lt; Tags::BondiH &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the linear factor which multiplies \(\bar{H}\) in the equation which determines the radial (y) dependence of the Bondi quantity \(H\).  <a href="structCce_1_1ComputeBondiIntegrand_3_01Tags_1_1LinearFactorForConjugate_3_01Tags_1_1BondiH_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1ComputeBondiIntegrand_3_01Tags_1_1PoleOfIntegrand_3_01Tags_1_1BondiH_01_4_01_4.html">ComputeBondiIntegrand&lt; Tags::PoleOfIntegrand&lt; Tags::BondiH &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the pole part of the integrand (right-hand side) of the equation which determines the radial (y) dependence of the Bondi quantity \(H\).  <a href="structCce_1_1ComputeBondiIntegrand_3_01Tags_1_1PoleOfIntegrand_3_01Tags_1_1BondiH_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1ComputeBondiIntegrand_3_01Tags_1_1PoleOfIntegrand_3_01Tags_1_1BondiQ_01_4_01_4.html">ComputeBondiIntegrand&lt; Tags::PoleOfIntegrand&lt; Tags::BondiQ &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the pole part of the integrand (right-hand side) of the equation which determines the radial (y) dependence of the Bondi quantity \(Q\).  <a href="structCce_1_1ComputeBondiIntegrand_3_01Tags_1_1PoleOfIntegrand_3_01Tags_1_1BondiQ_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1ComputeBondiIntegrand_3_01Tags_1_1PoleOfIntegrand_3_01Tags_1_1BondiW_01_4_01_4.html">ComputeBondiIntegrand&lt; Tags::PoleOfIntegrand&lt; Tags::BondiW &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the pole part of the integrand (right-hand side) of the equation which determines the radial (y) dependence of the Bondi quantity \(W\).  <a href="structCce_1_1ComputeBondiIntegrand_3_01Tags_1_1PoleOfIntegrand_3_01Tags_1_1BondiW_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1ComputeBondiIntegrand_3_01Tags_1_1RegularIntegrand_3_01Tags_1_1BondiH_01_4_01_4.html">ComputeBondiIntegrand&lt; Tags::RegularIntegrand&lt; Tags::BondiH &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the pole part of the integrand (right-hand side) of the equation which determines the radial (y) dependence of the Bondi quantity \(H\).  <a href="structCce_1_1ComputeBondiIntegrand_3_01Tags_1_1RegularIntegrand_3_01Tags_1_1BondiH_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1ComputeBondiIntegrand_3_01Tags_1_1RegularIntegrand_3_01Tags_1_1BondiQ_01_4_01_4.html">ComputeBondiIntegrand&lt; Tags::RegularIntegrand&lt; Tags::BondiQ &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the regular part of the integrand (right-hand side) of the equation which determines the radial (y) dependence of the Bondi quantity \(Q\).  <a href="structCce_1_1ComputeBondiIntegrand_3_01Tags_1_1RegularIntegrand_3_01Tags_1_1BondiQ_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1ComputeBondiIntegrand_3_01Tags_1_1RegularIntegrand_3_01Tags_1_1BondiW_01_4_01_4.html">ComputeBondiIntegrand&lt; Tags::RegularIntegrand&lt; Tags::BondiW &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the regular part of the integrand (right-hand side) of the equation which determines the radial (y) dependence of the Bondi quantity \(W\).  <a href="structCce_1_1ComputeBondiIntegrand_3_01Tags_1_1RegularIntegrand_3_01Tags_1_1BondiW_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1InitializeJ.html">InitializeJ</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize \(J\) on the first hypersurface from provided boundary values of \(J\), \(R\), and \(\partial_r J\).  <a href="structCce_1_1InitializeJ.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1pre__swsh__derivative__tags__to__compute__for.html">pre_swsh_derivative_tags_to_compute_for</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A typelist for the set of tags computed by the set of template specializations of <code>ComputePreSwshDerivatives</code>.  <a href="structCce_1_1pre__swsh__derivative__tags__to__compute__for.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1PrecomputeCceDependencies.html">PrecomputeCceDependencies</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A set of procedures for computing the set of inputs to the CCE integrand computations that can be computed before any of the intermediate integrands are evaluated.  <a href="structCce_1_1PrecomputeCceDependencies.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1PrecomputeCceDependencies_3_01BoundaryPrefix_00_01Tags_1_1BondiK_01_4.html">PrecomputeCceDependencies&lt; BoundaryPrefix, Tags::BondiK &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes \(K = \sqrt{1 + J \bar{J}}\).  <a href="structCce_1_1PrecomputeCceDependencies_3_01BoundaryPrefix_00_01Tags_1_1BondiK_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1PrecomputeCceDependencies_3_01BoundaryPrefix_00_01Tags_1_1BondiR_01_4.html">PrecomputeCceDependencies&lt; BoundaryPrefix, Tags::BondiR &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a volume version of Bondi radius of the worldtube \(R\) from its boundary value (by repeating it over the radial dimension)  <a href="structCce_1_1PrecomputeCceDependencies_3_01BoundaryPrefix_00_01Tags_1_1BondiR_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1PrecomputeCceDependencies_3_01BoundaryPrefix_00_01Tags_1_1DuRDividedByR_01_4.html">PrecomputeCceDependencies&lt; BoundaryPrefix, Tags::DuRDividedByR &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes \(\partial_u R / R\) from its boundary value (by repeating it over the radial dimension).  <a href="structCce_1_1PrecomputeCceDependencies_3_01BoundaryPrefix_00_01Tags_1_1DuRDividedByR_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1PrecomputeCceDependencies_3_01BoundaryPrefix_00_01Tags_1_1EthEthbarRDividedByR_01_4.html">PrecomputeCceDependencies&lt; BoundaryPrefix, Tags::EthEthbarRDividedByR &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes \(\eth \bar{\eth} R / R\) by differentiating and repeating the boundary value of \(R\).  <a href="structCce_1_1PrecomputeCceDependencies_3_01BoundaryPrefix_00_01Tags_1_1EthEthbarRDividedByR_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1PrecomputeCceDependencies_3_01BoundaryPrefix_00_01Tags_1_1EthEthRDividedByR_01_4.html">PrecomputeCceDependencies&lt; BoundaryPrefix, Tags::EthEthRDividedByR &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes \(\eth \eth R / R\) by differentiating and repeating the boundary value of \(R\).  <a href="structCce_1_1PrecomputeCceDependencies_3_01BoundaryPrefix_00_01Tags_1_1EthEthRDividedByR_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1PrecomputeCceDependencies_3_01BoundaryPrefix_00_01Tags_1_1EthRDividedByR_01_4.html">PrecomputeCceDependencies&lt; BoundaryPrefix, Tags::EthRDividedByR &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes \(\eth R / R\) by differentiating and repeating the boundary value of \(R\).  <a href="structCce_1_1PrecomputeCceDependencies_3_01BoundaryPrefix_00_01Tags_1_1EthRDividedByR_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1PrecomputeCceDependencies_3_01BoundaryPrefix_00_01Tags_1_1OneMinusY_01_4.html">PrecomputeCceDependencies&lt; BoundaryPrefix, Tags::OneMinusY &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes \(1 - y\) for the CCE system.  <a href="structCce_1_1PrecomputeCceDependencies_3_01BoundaryPrefix_00_01Tags_1_1OneMinusY_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1PreSwshDerivatives.html">PreSwshDerivatives</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A set of procedures for computing the set of inputs to the CCE integrand computations that are to be performed prior to the spin-weighted spherical harmonic differentiation (and for the first step in the series of integrations, after the <code><a class="el" href="structCce_1_1PrecomputeCceDependencies.html" title="A set of procedures for computing the set of inputs to the CCE integrand computations that can be com...">PrecomputeCceDependencies</a></code>)  <a href="structCce_1_1PreSwshDerivatives.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1PreSwshDerivatives_3_01Tags_1_1BondiJbar_01_4.html">PreSwshDerivatives&lt; Tags::BondiJbar &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute \(\bar{J}\).  <a href="structCce_1_1PreSwshDerivatives_3_01Tags_1_1BondiJbar_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1PreSwshDerivatives_3_01Tags_1_1BondiQbar_01_4.html">PreSwshDerivatives&lt; Tags::BondiQbar &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1PreSwshDerivatives_3_01Tags_1_1BondiUbar_01_4.html">PreSwshDerivatives&lt; Tags::BondiUbar &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute \(\bar{U}\).  <a href="structCce_1_1PreSwshDerivatives_3_01Tags_1_1BondiUbar_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1PreSwshDerivatives_3_01Tags_1_1Dy_3_01Spectral_1_1Swsh_1_1Tags_1_1Derivative_3_01Tag_00_01DerivKind_01_4_01_4_01_4.html">PreSwshDerivatives&lt; Tags::Dy&lt; Spectral::Swsh::Tags::Derivative&lt; Tag, DerivKind &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the derivative with respect to the numerical radial coordinate \(y\) of a quantity which is a spin-weighted spherical harmonic derivative.  <a href="structCce_1_1PreSwshDerivatives_3_01Tags_1_1Dy_3_01Spectral_1_1Swsh_1_1Tags_1_1Derivative_3_01Tag_00_01DerivKind_01_4_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1PreSwshDerivatives_3_01Tags_1_1Dy_3_01Tag_01_4_01_4.html">PreSwshDerivatives&lt; Tags::Dy&lt; Tag &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the derivative of the quantity represented by <code>Tag</code> with respect to the numerical radial coordinate \(y\).  <a href="structCce_1_1PreSwshDerivatives_3_01Tags_1_1Dy_3_01Tag_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1PreSwshDerivatives_3_01Tags_1_1Dy_3_01Tags_1_1BondiBeta_01_4_01_4.html">PreSwshDerivatives&lt; Tags::Dy&lt; Tags::BondiBeta &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the first derivative with respect to \(y\) of <code><a class="el" href="structCce_1_1Tags_1_1BondiBeta.html" title="Bondi parameter . ">Tags::BondiBeta</a></code>.  <a href="structCce_1_1PreSwshDerivatives_3_01Tags_1_1Dy_3_01Tags_1_1BondiBeta_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1PreSwshDerivatives_3_01Tags_1_1Dy_3_01Tags_1_1BondiU_01_4_01_4.html">PreSwshDerivatives&lt; Tags::Dy&lt; Tags::BondiU &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the first derivative with respect to \(y\) of <code><a class="el" href="structCce_1_1Tags_1_1BondiU.html" title="Bondi parameter . ">Tags::BondiU</a></code>.  <a href="structCce_1_1PreSwshDerivatives_3_01Tags_1_1Dy_3_01Tags_1_1BondiU_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1PreSwshDerivatives_3_01Tags_1_1Exp2Beta_01_4.html">PreSwshDerivatives&lt; Tags::Exp2Beta &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute \(\exp(2 \beta)\).  <a href="structCce_1_1PreSwshDerivatives_3_01Tags_1_1Exp2Beta_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1PreSwshDerivatives_3_01Tags_1_1JbarQMinus2EthBeta_01_4.html">PreSwshDerivatives&lt; Tags::JbarQMinus2EthBeta &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute \(\bar{J} * (Q - 2 \eth \beta)\).  <a href="structCce_1_1PreSwshDerivatives_3_01Tags_1_1JbarQMinus2EthBeta_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1PreSwshDerivatives_3_1_1Tags_1_1Multiplies_3_01Lhs_00_01Rhs_01_4_01_4.html">PreSwshDerivatives&lt;::Tags::Multiplies&lt; Lhs, Rhs &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the product of <code>Lhs</code> and <code>Rhs</code>.  <a href="structCce_1_1PreSwshDerivatives_3_1_1Tags_1_1Multiplies_3_01Lhs_00_01Rhs_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1PreSwshDerivatives_3_1_1Tags_1_1Multiplies_3_01Lhs_00_01Tags_1_1BondiJbar_01_4_01_4.html">PreSwshDerivatives&lt;::Tags::Multiplies&lt; Lhs, Tags::BondiJbar &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the product of \(\bar{J}\) and the quantity represented by <code>Rhs</code>.  <a href="structCce_1_1PreSwshDerivatives_3_1_1Tags_1_1Multiplies_3_01Lhs_00_01Tags_1_1BondiJbar_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1PreSwshDerivatives_3_1_1Tags_1_1Multiplies_3_01Tags_1_1BondiJbar_00_01Rhs_01_4_01_4.html">PreSwshDerivatives&lt;::Tags::Multiplies&lt; Tags::BondiJbar, Rhs &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the product of \(\bar{J}\) and the quantity represented by <code>Rhs</code>.  <a href="structCce_1_1PreSwshDerivatives_3_1_1Tags_1_1Multiplies_3_01Tags_1_1BondiJbar_00_01Rhs_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1PreSwshDerivatives_3_1_1Tags_1_1Multiplies_3_01Tags_1_1BondiUbar_00_01Rhs_01_4_01_4.html">PreSwshDerivatives&lt;::Tags::Multiplies&lt; Tags::BondiUbar, Rhs &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the product of \(\bar{U}\) and the quantity represented by <code>Rhs</code>.  <a href="structCce_1_1PreSwshDerivatives_3_1_1Tags_1_1Multiplies_3_01Tags_1_1BondiUbar_00_01Rhs_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1RadialIntegrateBondi.html">RadialIntegrateBondi</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computational structs for evaluating the hypersurface integrals during CCE evolution. These are compatible with use in <code><a class="el" href="group__DataBoxGroup.html#gac9900e6610ba0bce5834e8cb035d834d" title="Apply the invokable f mutating items MutateTags and taking as additional arguments ArgumentTags and a...">db::mutate_apply</a></code>.  <a href="structCce_1_1RadialIntegrateBondi.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1RadialIntegrateBondi_3_01Tags_1_1BondiH_01_4.html">RadialIntegrateBondi&lt; Tags::BondiH &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1RadialIntegrateBondi_3_01Tags_1_1BondiQ_01_4.html">RadialIntegrateBondi&lt; Tags::BondiQ &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1RadialIntegrateBondi_3_01Tags_1_1BondiW_01_4.html">RadialIntegrateBondi&lt; Tags::BondiW &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1second__swsh__derivative__tags__to__compute__for.html">second_swsh_derivative_tags_to_compute_for</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A typelist for the set of tags computed by multiple spin-weighted differentiation using utilities from the <code>Swsh</code> namespace.  <a href="structCce_1_1second__swsh__derivative__tags__to__compute__for.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structCce_1_1single__swsh__derivative__tags__to__compute__for.html">single_swsh_derivative_tags_to_compute_for</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A typelist for the set of tags computed by single spin-weighted differentiation using utilities from the <code>Swsh</code> namespace.  <a href="structCce_1_1single__swsh__derivative__tags__to__compute__for.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a310ba8247353a56c8345f00ca6c055cd"><td class="memItemLeft" align="right" valign="top"><a id="a310ba8247353a56c8345f00ca6c055cd"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>jacobian_tensor</b> = Tensor&lt; <a class="el" href="classDataVector.html">DataVector</a>, tmpl::integral_list&lt; <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/types/integer.html">std::int32_t</a>, 2, 1 &gt;, index_list&lt; <a class="el" href="group__TensorGroup.html#ga557beda9bce6c7f236213ec8b24b3ff3">SpatialIndex</a>&lt; 3, <a class="el" href="group__TensorGroup.html#ggaab1181edf2ab2b664b0f174223f08c28aff50b4aa1c9cc2197ef898436641c911">UpLo::Lo</a>, ::<a class="el" href="structFrame_1_1Spherical.html">Frame::Spherical</a>&lt;::<a class="el" href="structFrame_1_1Inertial.html">Frame::Inertial</a> &gt; &gt;, <a class="el" href="group__TensorGroup.html#ga557beda9bce6c7f236213ec8b24b3ff3">SpatialIndex</a>&lt; 3, <a class="el" href="group__TensorGroup.html#ggaab1181edf2ab2b664b0f174223f08c28a258f49887ef8d14ac268c92b02503aaa">UpLo::Up</a>, ::<a class="el" href="structFrame_1_1Inertial.html">Frame::Inertial</a> &gt; &gt;&gt;</td></tr>
<tr class="separator:a310ba8247353a56c8345f00ca6c055cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeac363c2404b9aeca44d4bfe485babc7"><td class="memItemLeft" align="right" valign="top"><a id="aeac363c2404b9aeca44d4bfe485babc7"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>inverse_jacobian_tensor</b> = Tensor&lt; <a class="el" href="classDataVector.html">DataVector</a>, tmpl::integral_list&lt; <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/types/integer.html">std::int32_t</a>, 2, 1 &gt;, index_list&lt; <a class="el" href="group__TensorGroup.html#ga557beda9bce6c7f236213ec8b24b3ff3">SpatialIndex</a>&lt; 3, <a class="el" href="group__TensorGroup.html#ggaab1181edf2ab2b664b0f174223f08c28aff50b4aa1c9cc2197ef898436641c911">UpLo::Lo</a>, ::<a class="el" href="structFrame_1_1Inertial.html">Frame::Inertial</a> &gt;, <a class="el" href="group__TensorGroup.html#ga557beda9bce6c7f236213ec8b24b3ff3">SpatialIndex</a>&lt; 3, <a class="el" href="group__TensorGroup.html#ggaab1181edf2ab2b664b0f174223f08c28a258f49887ef8d14ac268c92b02503aaa">UpLo::Up</a>, ::<a class="el" href="structFrame_1_1Spherical.html">Frame::Spherical</a>&lt;::<a class="el" href="structFrame_1_1Inertial.html">Frame::Inertial</a> &gt; &gt;&gt; &gt;</td></tr>
<tr class="separator:aeac363c2404b9aeca44d4bfe485babc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a613ab75a0e0153ef33518a6b3f358457"><td class="memTemplParams" colspan="2"><a id="a613ab75a0e0153ef33518a6b3f358457"></a>
template&lt;typename BondiVariable &gt; </td></tr>
<tr class="memitem:a613ab75a0e0153ef33518a6b3f358457"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCce.html#a613ab75a0e0153ef33518a6b3f358457">integrand_terms_to_compute_for_bondi_variable</a> = typename detail::integrand_terms_to_compute_for_bondi_variable_impl&lt; BondiVariable &gt;::type</td></tr>
<tr class="memdesc:a613ab75a0e0153ef33518a6b3f358457"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct for providing a <code>tmpl::list</code> of integrand tags that need to be computed before integration can proceed for a given Bondi variable tag. <br /></td></tr>
<tr class="separator:a613ab75a0e0153ef33518a6b3f358457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aa380f6f1dc1109be44f9ddbac98652"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCce.html#a6aa380f6f1dc1109be44f9ddbac98652">bondi_hypersurface_step_tags</a> = tmpl::list&lt; <a class="el" href="structCce_1_1Tags_1_1BondiBeta.html">Tags::BondiBeta</a>, <a class="el" href="structCce_1_1Tags_1_1BondiQ.html">Tags::BondiQ</a>, <a class="el" href="structCce_1_1Tags_1_1BondiU.html">Tags::BondiU</a>, <a class="el" href="structCce_1_1Tags_1_1BondiW.html">Tags::BondiW</a>, <a class="el" href="structCce_1_1Tags_1_1BondiH.html">Tags::BondiH</a> &gt;</td></tr>
<tr class="separator:a6aa380f6f1dc1109be44f9ddbac98652"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a393d5c196acb92779ba89acbc1fa686e"><td class="memTemplParams" colspan="2">template&lt;typename Tag &gt; </td></tr>
<tr class="memitem:a393d5c196acb92779ba89acbc1fa686e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCce.html#a393d5c196acb92779ba89acbc1fa686e">integrand_temporary_tags</a> = typename <a class="el" href="structCce_1_1ComputeBondiIntegrand.html">ComputeBondiIntegrand</a>&lt; Tag &gt;::temporary_tags</td></tr>
<tr class="separator:a393d5c196acb92779ba89acbc1fa686e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa00307a414eb1f569706cb7d7449fa4d"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename &gt; class BoundaryPrefix&gt; </td></tr>
<tr class="memitem:aa00307a414eb1f569706cb7d7449fa4d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCce.html#aa00307a414eb1f569706cb7d7449fa4d">pre_computation_boundary_tags</a> = tmpl::list&lt; BoundaryPrefix&lt; <a class="el" href="structCce_1_1Tags_1_1BondiR.html">Tags::BondiR</a> &gt;, BoundaryPrefix&lt; <a class="el" href="structCce_1_1Tags_1_1DuRDividedByR.html">Tags::DuRDividedByR</a> &gt; &gt;</td></tr>
<tr class="memdesc:aa00307a414eb1f569706cb7d7449fa4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A typelist for the set of <code>BoundaryValue</code> tags needed as an input to any of the template specializations of <code><a class="el" href="structCce_1_1PrecomputeCceDependencies.html" title="A set of procedures for computing the set of inputs to the CCE integrand computations that can be com...">PrecomputeCceDependencies</a></code>.  <a href="#aa00307a414eb1f569706cb7d7449fa4d">More...</a><br /></td></tr>
<tr class="separator:aa00307a414eb1f569706cb7d7449fa4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a597e56873fee952fd464981a692bfb"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCce.html#a0a597e56873fee952fd464981a692bfb">pre_computation_tags</a> = tmpl::list&lt; <a class="el" href="structCce_1_1Tags_1_1DuRDividedByR.html">Tags::DuRDividedByR</a>, <a class="el" href="structCce_1_1Tags_1_1EthRDividedByR.html">Tags::EthRDividedByR</a>, <a class="el" href="structCce_1_1Tags_1_1EthEthRDividedByR.html">Tags::EthEthRDividedByR</a>, <a class="el" href="structCce_1_1Tags_1_1EthEthbarRDividedByR.html">Tags::EthEthbarRDividedByR</a>, <a class="el" href="structCce_1_1Tags_1_1BondiK.html">Tags::BondiK</a>, <a class="el" href="structCce_1_1Tags_1_1OneMinusY.html">Tags::OneMinusY</a>, <a class="el" href="structCce_1_1Tags_1_1BondiR.html">Tags::BondiR</a> &gt;</td></tr>
<tr class="memdesc:a0a597e56873fee952fd464981a692bfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">A typelist for the set of tags computed by the set of template specializations of <code>PrecomputeCceDepedencies</code>.  <a href="#a0a597e56873fee952fd464981a692bfb">More...</a><br /></td></tr>
<tr class="separator:a0a597e56873fee952fd464981a692bfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3f639bb3b07cc123bdf53c26dbf0fff"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCce.html#ad3f639bb3b07cc123bdf53c26dbf0fff">all_swsh_derivative_tags</a> = tmpl::remove_duplicates&lt; tmpl::flatten&lt; tmpl::transform&lt; <a class="el" href="namespaceCce.html#a6aa380f6f1dc1109be44f9ddbac98652">bondi_hypersurface_step_tags</a>, tmpl::bind&lt; tmpl::list, <a class="el" href="structCce_1_1single__swsh__derivative__tags__to__compute__for.html">single_swsh_derivative_tags_to_compute_for</a>&lt; tmpl::_1 &gt;, <a class="el" href="structCce_1_1second__swsh__derivative__tags__to__compute__for.html">second_swsh_derivative_tags_to_compute_for</a>&lt; tmpl::_1 &gt; &gt;&gt; &gt;&gt;</td></tr>
<tr class="memdesc:ad3f639bb3b07cc123bdf53c26dbf0fff"><td class="mdescLeft">&#160;</td><td class="mdescRight">A typelist for the set of tags computed by spin-weighted differentiation using utilities from the <code>Swsh</code> namespace.  <a href="#ad3f639bb3b07cc123bdf53c26dbf0fff">More...</a><br /></td></tr>
<tr class="separator:ad3f639bb3b07cc123bdf53c26dbf0fff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cbd52ad55ee87beb6abf5857c2db60a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCce.html#a9cbd52ad55ee87beb6abf5857c2db60a">all_transform_buffer_tags</a> = tmpl::remove_duplicates&lt; tmpl::flatten&lt; tmpl::transform&lt; <a class="el" href="namespaceCce.html#ad3f639bb3b07cc123bdf53c26dbf0fff">all_swsh_derivative_tags</a>, tmpl::bind&lt; <a class="el" href="group__SwshGroup.html#ga3a19e1d6fbdabe80a1252971f6594cfb">Spectral::Swsh::coefficient_buffer_tags_for_derivative_tag</a>, tmpl::_1 &gt; &gt;&gt; &gt;</td></tr>
<tr class="memdesc:a9cbd52ad55ee87beb6abf5857c2db60a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A typelist for the full set of coefficient buffers needed to process all of the tags in <code>all_swsh_derivative_tags</code> using batch processing provided in <code>mutate_all_swsh_derivatives_for_tag</code>.  <a href="#a9cbd52ad55ee87beb6abf5857c2db60a">More...</a><br /></td></tr>
<tr class="separator:a9cbd52ad55ee87beb6abf5857c2db60a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8da977a43161ce3f5b046e3513724f54"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCce.html#a8da977a43161ce3f5b046e3513724f54">all_pre_swsh_derivative_tags</a> = tmpl::remove_duplicates&lt; tmpl::flatten&lt; tmpl::transform&lt; <a class="el" href="namespaceCce.html#a6aa380f6f1dc1109be44f9ddbac98652">bondi_hypersurface_step_tags</a>, tmpl::bind&lt; tmpl::list, <a class="el" href="structCce_1_1pre__swsh__derivative__tags__to__compute__for.html">pre_swsh_derivative_tags_to_compute_for</a>&lt; tmpl::_1 &gt;, tmpl::_1, tmpl::bind&lt; <a class="el" href="structCce_1_1Tags_1_1Dy.html">Tags::Dy</a>, tmpl::_1 &gt; &gt;&gt; &gt;&gt;</td></tr>
<tr class="memdesc:a8da977a43161ce3f5b046e3513724f54"><td class="mdescLeft">&#160;</td><td class="mdescRight">A typelist for the full set of tags needed as direct or indirect input to any <code><a class="el" href="structCce_1_1ComputeBondiIntegrand.html" title="Computes one of the inputs for the integration of one of the Characteristic hypersurface equations...">ComputeBondiIntegrand</a></code> that are computed any specialization of <code>ComputePreSwshDerivatives</code>.  <a href="#a8da977a43161ce3f5b046e3513724f54">More...</a><br /></td></tr>
<tr class="separator:a8da977a43161ce3f5b046e3513724f54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad3fb4002f488cbb49de99c785b1c1b5"><td class="memTemplParams" colspan="2"><a id="aad3fb4002f488cbb49de99c785b1c1b5"></a>
template&lt;typename Tag &gt; </td></tr>
<tr class="memitem:aad3fb4002f488cbb49de99c785b1c1b5"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCce.html#aad3fb4002f488cbb49de99c785b1c1b5">OnDemandInputsForSwshJacobian</a> = detail::OnDemandInputsForSwshJacobianImpl&lt; Tag, <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/types/integral_constant.html">std::integral_constant</a>&lt; int, Tag::type::type::spin &gt;, <a class="elRef" doxygen="/work/spectre/docs/config/cppreference-doxygen-web.tag.xml:http://en.cppreference.com/w/" href="http://en.cppreference.com/w/cpp/types/integral_constant.html">std::true_type</a> &gt;</td></tr>
<tr class="memdesc:aad3fb4002f488cbb49de99c785b1c1b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide an expression template or reference to <code>Tag</code>, intended for situations for which a repeated computation is more desirable than storing a value in the <a class="el" href="group__DataBoxGroup.html">DataBox</a> (e.g. for conjugation and simple product rule expansion). <br /></td></tr>
<tr class="separator:aad3fb4002f488cbb49de99c785b1c1b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ae3c2adc1f0d1a2b33905452c9b9a645b"><td class="memTemplParams" colspan="2"><a id="ae3c2adc1f0d1a2b33905452c9b9a645b"></a>
template&lt;typename Tag &gt; </td></tr>
<tr class="memitem:ae3c2adc1f0d1a2b33905452c9b9a645b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>pre_swsh_derivative_tags_to_compute_for_t</b> = typename <a class="el" href="structCce_1_1pre__swsh__derivative__tags__to__compute__for.html">pre_swsh_derivative_tags_to_compute_for</a>&lt; Tag &gt;::type</td></tr>
<tr class="separator:ae3c2adc1f0d1a2b33905452c9b9a645b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a70495dd357c5c456b5ed2fd65cbcd2de"><td class="memTemplParams" colspan="2"><a id="a70495dd357c5c456b5ed2fd65cbcd2de"></a>
template&lt;typename Tag &gt; </td></tr>
<tr class="memitem:a70495dd357c5c456b5ed2fd65cbcd2de"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>single_swsh_derivative_tags_to_compute_for_t</b> = typename <a class="el" href="structCce_1_1single__swsh__derivative__tags__to__compute__for.html">single_swsh_derivative_tags_to_compute_for</a>&lt; Tag &gt;::type</td></tr>
<tr class="separator:a70495dd357c5c456b5ed2fd65cbcd2de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a85d532741987969e9994e20db3c5eba8"><td class="memTemplParams" colspan="2"><a id="a85d532741987969e9994e20db3c5eba8"></a>
template&lt;typename Tag &gt; </td></tr>
<tr class="memitem:a85d532741987969e9994e20db3c5eba8"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>second_swsh_derivative_tags_to_compute_for_t</b> = typename <a class="el" href="structCce_1_1single__swsh__derivative__tags__to__compute__for.html">single_swsh_derivative_tags_to_compute_for</a>&lt; Tag &gt;::type</td></tr>
<tr class="separator:a85d532741987969e9994e20db3c5eba8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a6595b69e95906157b1c6016c33ba476f"><td class="memItemLeft" align="right" valign="top"><a id="a6595b69e95906157b1c6016c33ba476f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>trigonometric_functions_on_swsh_collocation</b> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; *&gt; cos_phi, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; *&gt; cos_theta, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; *&gt; sin_phi, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; *&gt; sin_theta, const size_t l_max) noexcept</td></tr>
<tr class="separator:a6595b69e95906157b1c6016c33ba476f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04a2f98f8250ec63ddfec6a23ef2c6b1"><td class="memItemLeft" align="right" valign="top"><a id="a04a2f98f8250ec63ddfec6a23ef2c6b1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>cartesian_to_spherical_coordinates_and_jacobians</b> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; *&gt; unit_cartesian_coords, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; jacobian_tensor *&gt; cartesian_to_spherical_jacobian, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; inverse_jacobian_tensor *&gt; inverse_cartesian_to_spherical_jacobian, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;cos_phi, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;cos_theta, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;sin_phi, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;sin_theta, const double extraction_radius) noexcept</td></tr>
<tr class="separator:a04a2f98f8250ec63ddfec6a23ef2c6b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ea0ea74f974cecd77aeb5b16e98e26e"><td class="memItemLeft" align="right" valign="top"><a id="a0ea0ea74f974cecd77aeb5b16e98e26e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>null_metric_and_derivative</b> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; *&gt; du_null_metric, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; *&gt; null_metric, const jacobian_tensor &amp;cartesian_to_spherical_jacobian, const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;dt_spacetime_metric, const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;spacetime_metric) noexcept</td></tr>
<tr class="separator:a0ea0ea74f974cecd77aeb5b16e98e26e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90364dc4afb3dc5ca2a26e9885bb7153"><td class="memItemLeft" align="right" valign="top"><a id="a90364dc4afb3dc5ca2a26e9885bb7153"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>worldtube_normal_and_derivatives</b> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; *&gt; worldtube_normal, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; *&gt; dt_worldtube_normal, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;cos_phi, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;cos_theta, const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;spacetime_metric, const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;dt_spacetime_metric, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;sin_phi, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;sin_theta, const tnsr::II&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;inverse_spatial_metric) noexcept</td></tr>
<tr class="separator:a90364dc4afb3dc5ca2a26e9885bb7153"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6bef9490b91f740d9d23bab51f12a8d"><td class="memItemLeft" align="right" valign="top"><a id="aa6bef9490b91f740d9d23bab51f12a8d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>null_vector_l_and_derivatives</b> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::A&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; *&gt; du_null_l, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::A&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; *&gt; null_l, const tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;dt_worldtube_normal, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;dt_lapse, const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;dt_spacetime_metric, const tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;dt_shift, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;lapse, const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;spacetime_metric, const tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;shift, const tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;worldtube_normal) noexcept</td></tr>
<tr class="separator:aa6bef9490b91f740d9d23bab51f12a8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba742cdeceeed7f7960d389169d2aa75"><td class="memItemLeft" align="right" valign="top"><a id="aba742cdeceeed7f7960d389169d2aa75"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>dlambda_null_metric_and_inverse</b> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; *&gt; dlambda_null_metric, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::AA&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; *&gt; dlambda_inverse_null_metric, const tnsr::iA&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;angular_d_null_l, const jacobian_tensor &amp;cartesian_to_spherical_jacobian, const tnsr::iaa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;phi, const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;dt_spacetime_metric, const tnsr::A&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;du_null_l, const tnsr::AA&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;inverse_null_metric, const tnsr::A&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;null_l, const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;spacetime_metric) noexcept</td></tr>
<tr class="separator:aba742cdeceeed7f7960d389169d2aa75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03aea52b9603e24b0a310a6cbdd11fff"><td class="memItemLeft" align="right" valign="top"><a id="a03aea52b9603e24b0a310a6cbdd11fff"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>d_bondi_r</b> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::a&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; *&gt; d_bondi_r, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 0 &gt;&gt; &amp;bondi_r, const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;dlambda_null_metric, const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;du_null_metric, const tnsr::AA&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;inverse_null_metric, const size_t l_max) noexcept</td></tr>
<tr class="separator:a03aea52b9603e24b0a310a6cbdd11fff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadf5dec8b82f1089fdb12c0e74e52e73"><td class="memItemLeft" align="right" valign="top"><a id="aadf5dec8b82f1089fdb12c0e74e52e73"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>dyads</b> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::i&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 2, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; *&gt; down_dyad, const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::I&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 2, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; *&gt; up_dyad) noexcept</td></tr>
<tr class="separator:aadf5dec8b82f1089fdb12c0e74e52e73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87b43a20534ee24795c4b343c8045c39"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCce.html#a87b43a20534ee24795c4b343c8045c39">trigonometric_functions_on_swsh_collocation</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; *&gt; cos_phi, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; *&gt; cos_theta, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; *&gt; sin_phi, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; *&gt; sin_theta, size_t l_max) noexcept</td></tr>
<tr class="memdesc:a87b43a20534ee24795c4b343c8045c39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs the collocation values for \(\cos(\phi)\), \(\cos(\theta)\), \(\sin(\phi)\), and \(\sin(\theta)\), returned by <code>not_null</code> pointer in that order.  <a href="#a87b43a20534ee24795c4b343c8045c39">More...</a><br /></td></tr>
<tr class="separator:a87b43a20534ee24795c4b343c8045c39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b18c2f467fe80ff7281445f4953f8a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCce.html#a2b18c2f467fe80ff7281445f4953f8a6">cartesian_to_spherical_coordinates_and_jacobians</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; *&gt; unit_cartesian_coords, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; jacobian_tensor *&gt; cartesian_to_spherical_jacobian, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; inverse_jacobian_tensor *&gt; inverse_cartesian_to_spherical_jacobian, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;cos_phi, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;cos_theta, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;sin_phi, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;sin_theta, double extraction_radius) noexcept</td></tr>
<tr class="memdesc:a2b18c2f467fe80ff7281445f4953f8a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates both the Jacobian and inverse Jacobian between Cartesian and spherical coordinates, and the coordinates themselves.  <a href="#a2b18c2f467fe80ff7281445f4953f8a6">More...</a><br /></td></tr>
<tr class="separator:a2b18c2f467fe80ff7281445f4953f8a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b1e172af7db7136790d0adc298e41e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCce.html#a4b1e172af7db7136790d0adc298e41e2">null_metric_and_derivative</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; *&gt; du_null_metric, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; *&gt; null_metric, const jacobian_tensor &amp;cartesian_to_spherical_jacobian, const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;dt_spacetime_metric, const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;spacetime_metric) noexcept</td></tr>
<tr class="memdesc:a4b1e172af7db7136790d0adc298e41e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the spacetime metric and its first derivative in the intermediate radial null coordinates.  <a href="#a4b1e172af7db7136790d0adc298e41e2">More...</a><br /></td></tr>
<tr class="separator:a4b1e172af7db7136790d0adc298e41e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c376c6944c906be71dafc0a37761a45"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCce.html#a9c376c6944c906be71dafc0a37761a45">worldtube_normal_and_derivatives</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; *&gt; worldtube_normal, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; *&gt; dt_worldtube_normal, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;cos_phi, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;cos_theta, const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;spacetime_metric, const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;dt_spacetime_metric, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;sin_phi, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;sin_theta, const tnsr::II&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;inverse_spatial_metric) noexcept</td></tr>
<tr class="memdesc:a9c376c6944c906be71dafc0a37761a45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the spatial unit normal vector \(s^i\) to the spherical worldtube surface and its first time derivative.  <a href="#a9c376c6944c906be71dafc0a37761a45">More...</a><br /></td></tr>
<tr class="separator:a9c376c6944c906be71dafc0a37761a45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f0fbfceb7e1252112260c1d02a09961"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCce.html#a9f0fbfceb7e1252112260c1d02a09961">null_vector_l_and_derivatives</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::A&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; *&gt; du_null_l, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::A&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; *&gt; null_l, const tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;dt_worldtube_normal, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;dt_lapse, const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;dt_spacetime_metric, const tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;dt_shift, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;lapse, const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;spacetime_metric, const tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;shift, const tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;worldtube_normal) noexcept</td></tr>
<tr class="memdesc:a9f0fbfceb7e1252112260c1d02a09961"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the null 4-vector \(l^\mu\) on the worldtube surface that is to be used as the CCE hypersurface generator, and the first time derivative \(\partial_u l^\mu\).  <a href="#a9f0fbfceb7e1252112260c1d02a09961">More...</a><br /></td></tr>
<tr class="separator:a9f0fbfceb7e1252112260c1d02a09961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a518614109b0f0fdfe5082f8699343b07"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCce.html#a518614109b0f0fdfe5082f8699343b07">dlambda_null_metric_and_inverse</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; *&gt; dlambda_null_metric, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::AA&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; *&gt; dlambda_inverse_null_metric, const tnsr::iA&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;angular_d_null_l, const jacobian_tensor &amp;cartesian_to_spherical_jacobian, const tnsr::iaa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;phi, const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;dt_spacetime_metric, const tnsr::A&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;du_null_l, const tnsr::AA&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;inverse_null_metric, const tnsr::A&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;null_l, const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;spacetime_metric) noexcept</td></tr>
<tr class="memdesc:a518614109b0f0fdfe5082f8699343b07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the partial derivative of the spacetime metric and inverse spacetime metric in the intermediate null radial coordinates with respect to the null generator \(l^\mu\).  <a href="#a518614109b0f0fdfe5082f8699343b07">More...</a><br /></td></tr>
<tr class="separator:a518614109b0f0fdfe5082f8699343b07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4badb01ac37f2d368a259ef85fb823e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCce.html#ac4badb01ac37f2d368a259ef85fb823e">d_bondi_r</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::a&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; *&gt; d_bondi_r, const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 0 &gt;&gt; &amp;bondi_r, const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;dlambda_null_metric, const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;du_null_metric, const tnsr::AA&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;inverse_null_metric, size_t l_max) noexcept</td></tr>
<tr class="memdesc:ac4badb01ac37f2d368a259ef85fb823e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the full 4-dimensional partial of the Bondi radius with respect to the intermediate null coordinates.  <a href="#ac4badb01ac37f2d368a259ef85fb823e">More...</a><br /></td></tr>
<tr class="separator:ac4badb01ac37f2d368a259ef85fb823e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef6b36590b1996c6af1da396719c0a1d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCce.html#aef6b36590b1996c6af1da396719c0a1d">dyads</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::i&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 2, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; *&gt; down_dyad, <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::I&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 2, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; *&gt; up_dyad) noexcept</td></tr>
<tr class="memdesc:aef6b36590b1996c6af1da396719c0a1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the complex angular dyads used to define the spin-weighted scalars in the CCE system.  <a href="#aef6b36590b1996c6af1da396719c0a1d">More...</a><br /></td></tr>
<tr class="separator:aef6b36590b1996c6af1da396719c0a1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d126eba6a887771c53fc28f55eb36e6"><td class="memItemLeft" align="right" valign="top"><a id="a7d126eba6a887771c53fc28f55eb36e6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>logical_partial_directional_derivative_of_complex</b> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a> *&gt; d_u, const <a class="el" href="classComplexDataVector.html">ComplexDataVector</a> &amp;u, const <a class="el" href="classMesh.html">Mesh</a>&lt; 3 &gt; &amp;mesh, const size_t dimension_to_differentiate) noexcept</td></tr>
<tr class="separator:a7d126eba6a887771c53fc28f55eb36e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a246fe522bad41a8830e114c7d5e136e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCce.html#a246fe522bad41a8830e114c7d5e136e3">logical_partial_directional_derivative_of_complex</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a> *&gt; d_u, const <a class="el" href="classComplexDataVector.html">ComplexDataVector</a> &amp;u, const <a class="el" href="classMesh.html">Mesh</a>&lt; 3 &gt; &amp;mesh, size_t dimension_to_differentiate) noexcept</td></tr>
<tr class="memdesc:a246fe522bad41a8830e114c7d5e136e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the partial derivative along a particular direction determined by the <code>dimension_to_differentiate</code>. The input <code>u</code> is differentiated with the spectral matrix and the solution is placed in <code>d_u</code>.  <a href="#a246fe522bad41a8830e114c7d5e136e3">More...</a><br /></td></tr>
<tr class="separator:a246fe522bad41a8830e114c7d5e136e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af367dfeb1f3ee40aca23c628e9809ac1"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classMatrix.html">Matrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCce.html#af367dfeb1f3ee40aca23c628e9809ac1">precomputed_cce_q_integrator</a> (size_t number_of_radial_grid_points) noexcept</td></tr>
<tr class="memdesc:af367dfeb1f3ee40aca23c628e9809ac1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to a lazily cached integration matrix for the \(Q\) and \(W\) equations in CCE hypersurface evaluation.  <a href="#af367dfeb1f3ee40aca23c628e9809ac1">More...</a><br /></td></tr>
<tr class="separator:af367dfeb1f3ee40aca23c628e9809ac1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca83d5070828ccc7669f4a6b2dcbb634"><td class="memItemLeft" align="right" valign="top"><a id="aca83d5070828ccc7669f4a6b2dcbb634"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>radial_integrate_cce_pole_equations</b> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a> *&gt; integral_result, const <a class="el" href="classComplexDataVector.html">ComplexDataVector</a> &amp;pole_of_integrand, const <a class="el" href="classComplexDataVector.html">ComplexDataVector</a> &amp;regular_integrand, const <a class="el" href="classComplexDataVector.html">ComplexDataVector</a> &amp;boundary, const <a class="el" href="classComplexDataVector.html">ComplexDataVector</a> &amp;one_minus_y, const size_t l_max, const size_t number_of_radial_points) noexcept</td></tr>
<tr class="separator:aca83d5070828ccc7669f4a6b2dcbb634"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8001cac388464a9afee45fe2787acb3a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceCce.html#a8001cac388464a9afee45fe2787acb3a">radial_integrate_cce_pole_equations</a> (<a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a> *&gt; integral_result, const <a class="el" href="classComplexDataVector.html">ComplexDataVector</a> &amp;pole_of_integrand, const <a class="el" href="classComplexDataVector.html">ComplexDataVector</a> &amp;regular_integrand, const <a class="el" href="classComplexDataVector.html">ComplexDataVector</a> &amp;boundary, const <a class="el" href="classComplexDataVector.html">ComplexDataVector</a> &amp;one_minus_y, size_t l_max, size_t number_of_radial_points) noexcept</td></tr>
<tr class="memdesc:a8001cac388464a9afee45fe2787acb3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility function for evaluating the \(Q\) and \(W\) hypersurface integrals during CCE evolution.  <a href="#a8001cac388464a9afee45fe2787acb3a">More...</a><br /></td></tr>
<tr class="separator:a8001cac388464a9afee45fe2787acb3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9aaac2c0f9818a9f6c9b1f311a373c5"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename &gt; class BoundaryPrefix, typename DataBoxType &gt; </td></tr>
<tr class="memitem:ad9aaac2c0f9818a9f6c9b1f311a373c5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCce.html#ad9aaac2c0f9818a9f6c9b1f311a373c5">mutate_all_precompute_cce_dependencies</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; DataBoxType *&gt; box) noexcept</td></tr>
<tr class="memdesc:ad9aaac2c0f9818a9f6c9b1f311a373c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience routine for computing all of the CCE inputs to integrand computation that do not depend on intermediate integrand results. It should be executed before moving through the hierarchy of integrands.  <a href="#ad9aaac2c0f9818a9f6c9b1f311a373c5">More...</a><br /></td></tr>
<tr class="separator:ad9aaac2c0f9818a9f6c9b1f311a373c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ea7655c4828aea4ec5a29941d709860"><td class="memTemplParams" colspan="2">template&lt;typename BondiValueTag , typename DataBoxType &gt; </td></tr>
<tr class="memitem:a0ea7655c4828aea4ec5a29941d709860"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCce.html#a0ea7655c4828aea4ec5a29941d709860">mutate_all_pre_swsh_derivatives_for_tag</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; DataBoxType *&gt; box) noexcept</td></tr>
<tr class="memdesc:a0ea7655c4828aea4ec5a29941d709860"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates the set of inputs to the CCE integrand for <code>BondiValueTag</code> that do not involve spin-weighted angular differentiation.  <a href="#a0ea7655c4828aea4ec5a29941d709860">More...</a><br /></td></tr>
<tr class="separator:a0ea7655c4828aea4ec5a29941d709860"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a710c185e2efce13bd57e2414145c2172"><td class="memTemplParams" colspan="2">template&lt;typename BondiValueTag , typename DataBoxTagList &gt; </td></tr>
<tr class="memitem:a710c185e2efce13bd57e2414145c2172"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceCce.html#a710c185e2efce13bd57e2414145c2172">mutate_all_swsh_derivatives_for_tag</a> (const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classdb_1_1DataBox.html">db::DataBox</a>&lt; DataBoxTagList &gt; *&gt; box) noexcept</td></tr>
<tr class="memdesc:a710c185e2efce13bd57e2414145c2172"><td class="mdescLeft">&#160;</td><td class="mdescRight">This routine evaluates the set of inputs to the CCE integrand for <code>BondiValueTag</code> which are spin-weighted angular derivatives.  <a href="#a710c185e2efce13bd57e2414145c2172">More...</a><br /></td></tr>
<tr class="separator:a710c185e2efce13bd57e2414145c2172"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Contains functionality for Cauchy Characteristic Extraction. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a8da977a43161ce3f5b046e3513724f54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8da977a43161ce3f5b046e3513724f54">&#9670;&nbsp;</a></span>all_pre_swsh_derivative_tags</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceCce.html#a8da977a43161ce3f5b046e3513724f54">Cce::all_pre_swsh_derivative_tags</a> = typedef tmpl::remove_duplicates&lt;tmpl::flatten&lt;tmpl::transform&lt; <a class="el" href="namespaceCce.html#a6aa380f6f1dc1109be44f9ddbac98652">bondi_hypersurface_step_tags</a>, tmpl::bind&lt;tmpl::list, <a class="el" href="structCce_1_1pre__swsh__derivative__tags__to__compute__for.html">pre_swsh_derivative_tags_to_compute_for</a>&lt;tmpl::_1&gt;, tmpl::_1, tmpl::bind&lt;<a class="el" href="structCce_1_1Tags_1_1Dy.html">Tags::Dy</a>, tmpl::_1&gt; &gt;&gt; &gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A typelist for the full set of tags needed as direct or indirect input to any <code><a class="el" href="structCce_1_1ComputeBondiIntegrand.html" title="Computes one of the inputs for the integration of one of the Characteristic hypersurface equations...">ComputeBondiIntegrand</a></code> that are computed any specialization of <code>ComputePreSwshDerivatives</code>. </p>
<h3>Details</h3>
<p>This is provided for easy and maintainable construction of a <code>Variables</code> or <a class="el" href="group__DataBoxGroup.html">DataBox</a> with all of the quantities needed for a CCE computation or component. The data structures represented by these tags should each have size <code>number_of_radial_points * Spectral::Swsh::number_of_swsh_collocation_points(l_max)</code>. </p>

</div>
</div>
<a id="ad3f639bb3b07cc123bdf53c26dbf0fff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3f639bb3b07cc123bdf53c26dbf0fff">&#9670;&nbsp;</a></span>all_swsh_derivative_tags</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceCce.html#ad3f639bb3b07cc123bdf53c26dbf0fff">Cce::all_swsh_derivative_tags</a> = typedef tmpl::remove_duplicates&lt;tmpl::flatten&lt;tmpl::transform&lt; <a class="el" href="namespaceCce.html#a6aa380f6f1dc1109be44f9ddbac98652">bondi_hypersurface_step_tags</a>, tmpl::bind&lt;tmpl::list, <a class="el" href="structCce_1_1single__swsh__derivative__tags__to__compute__for.html">single_swsh_derivative_tags_to_compute_for</a>&lt;tmpl::_1&gt;, <a class="el" href="structCce_1_1second__swsh__derivative__tags__to__compute__for.html">second_swsh_derivative_tags_to_compute_for</a>&lt;tmpl::_1&gt; &gt;&gt; &gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A typelist for the set of tags computed by spin-weighted differentiation using utilities from the <code>Swsh</code> namespace. </p>
<h3>Details</h3>
<p>This is provided for easy and maintainable construction of a <code>Variables</code> or <a class="el" href="group__DataBoxGroup.html">DataBox</a> with all of the quantities needed for a CCE computation or component. The data structures represented by these tags should each have size <code>number_of_radial_points * Spectral::Swsh::number_of_swsh_collocation_points(l_max)</code>. All of these tags (for a given integrated Bondi quantity) may be computed at once if using a <a class="el" href="group__DataBoxGroup.html">DataBox</a> using the template <code>mutate_all_swsh_derivatives_for_tag</code>. Individual tag computation is not provided in a convenient interface, as there is significant savings in aggregating spin-weighted differentiation steps. The full set of integrated Bondi quantities is available from the typelist <code>bondi_hypersurface_step_tags</code>. </p>

</div>
</div>
<a id="a9cbd52ad55ee87beb6abf5857c2db60a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cbd52ad55ee87beb6abf5857c2db60a">&#9670;&nbsp;</a></span>all_transform_buffer_tags</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceCce.html#a9cbd52ad55ee87beb6abf5857c2db60a">Cce::all_transform_buffer_tags</a> = typedef tmpl::remove_duplicates&lt;tmpl::flatten&lt;tmpl::transform&lt; <a class="el" href="namespaceCce.html#ad3f639bb3b07cc123bdf53c26dbf0fff">all_swsh_derivative_tags</a>, tmpl::bind&lt;<a class="el" href="group__SwshGroup.html#ga3a19e1d6fbdabe80a1252971f6594cfb">Spectral::Swsh::coefficient_buffer_tags_for_derivative_tag</a>, tmpl::_1&gt; &gt;&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A typelist for the full set of coefficient buffers needed to process all of the tags in <code>all_swsh_derivative_tags</code> using batch processing provided in <code>mutate_all_swsh_derivatives_for_tag</code>. </p>
<h3>Details</h3>
<p>This is provided for easy and maintainable construction of a <code>Variables</code> or <a class="el" href="group__DataBoxGroup.html">DataBox</a> with all of the quantities needed for a CCE computation or component. The data structures represented by these tags should each have size <code>number_of_radial_points * Spectral::Swsh::size_of_libsharp_coefficient_vector(l_max)</code>. Providing buffers associated with these tags is necessary for the use of the aggregated computation <code>mutate_all_swsh_derivatives_for_tag</code>. </p>

</div>
</div>
<a id="a6aa380f6f1dc1109be44f9ddbac98652"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6aa380f6f1dc1109be44f9ddbac98652">&#9670;&nbsp;</a></span>bondi_hypersurface_step_tags</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceCce.html#a6aa380f6f1dc1109be44f9ddbac98652">Cce::bondi_hypersurface_step_tags</a> = typedef tmpl::list&lt;<a class="el" href="structCce_1_1Tags_1_1BondiBeta.html">Tags::BondiBeta</a>, <a class="el" href="structCce_1_1Tags_1_1BondiQ.html">Tags::BondiQ</a>, <a class="el" href="structCce_1_1Tags_1_1BondiU.html">Tags::BondiU</a>, <a class="el" href="structCce_1_1Tags_1_1BondiW.html">Tags::BondiW</a>, <a class="el" href="structCce_1_1Tags_1_1BondiH.html">Tags::BondiH</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The set of Bondi quantities computed by hypersurface step, in the required order of computation </p>

</div>
</div>
<a id="a393d5c196acb92779ba89acbc1fa686e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a393d5c196acb92779ba89acbc1fa686e">&#9670;&nbsp;</a></span>integrand_temporary_tags</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tag &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceCce.html#a393d5c196acb92779ba89acbc1fa686e">Cce::integrand_temporary_tags</a> = typedef typename <a class="el" href="structCce_1_1ComputeBondiIntegrand.html">ComputeBondiIntegrand</a>&lt;Tag&gt;::temporary_tags</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Metafunction that is a <code>tmpl::list</code> of the temporary tags taken by the <code><a class="el" href="structCce_1_1ComputeBondiIntegrand.html" title="Computes one of the inputs for the integration of one of the Characteristic hypersurface equations...">ComputeBondiIntegrand</a></code> computational struct. </p>

</div>
</div>
<a id="aa00307a414eb1f569706cb7d7449fa4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa00307a414eb1f569706cb7d7449fa4d">&#9670;&nbsp;</a></span>pre_computation_boundary_tags</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename &gt; class BoundaryPrefix&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceCce.html#aa00307a414eb1f569706cb7d7449fa4d">Cce::pre_computation_boundary_tags</a> = typedef tmpl::list&lt;BoundaryPrefix&lt;<a class="el" href="structCce_1_1Tags_1_1BondiR.html">Tags::BondiR</a>&gt;, BoundaryPrefix&lt;<a class="el" href="structCce_1_1Tags_1_1DuRDividedByR.html">Tags::DuRDividedByR</a>&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A typelist for the set of <code>BoundaryValue</code> tags needed as an input to any of the template specializations of <code><a class="el" href="structCce_1_1PrecomputeCceDependencies.html" title="A set of procedures for computing the set of inputs to the CCE integrand computations that can be com...">PrecomputeCceDependencies</a></code>. </p>
<h3>Details</h3>
<p>This is provided for easy and maintainable construction of a <code>Variables</code> or <a class="el" href="group__DataBoxGroup.html">DataBox</a> with all of the quantities necessary for a CCE computation or portion thereof. A container of these tags should have size <code>Spectral::Swsh::number_of_swsh_collocation_points(l_max)</code>. </p>

</div>
</div>
<a id="a0a597e56873fee952fd464981a692bfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a597e56873fee952fd464981a692bfb">&#9670;&nbsp;</a></span>pre_computation_tags</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceCce.html#a0a597e56873fee952fd464981a692bfb">Cce::pre_computation_tags</a> = typedef tmpl::list&lt;<a class="el" href="structCce_1_1Tags_1_1DuRDividedByR.html">Tags::DuRDividedByR</a>, <a class="el" href="structCce_1_1Tags_1_1EthRDividedByR.html">Tags::EthRDividedByR</a>, <a class="el" href="structCce_1_1Tags_1_1EthEthRDividedByR.html">Tags::EthEthRDividedByR</a>, <a class="el" href="structCce_1_1Tags_1_1EthEthbarRDividedByR.html">Tags::EthEthbarRDividedByR</a>, <a class="el" href="structCce_1_1Tags_1_1BondiK.html">Tags::BondiK</a>, <a class="el" href="structCce_1_1Tags_1_1OneMinusY.html">Tags::OneMinusY</a>, <a class="el" href="structCce_1_1Tags_1_1BondiR.html">Tags::BondiR</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A typelist for the set of tags computed by the set of template specializations of <code>PrecomputeCceDepedencies</code>. </p>
<h3>Details</h3>
<p>This is provided for easy and maintainable construction of a <code>Variables</code> or <a class="el" href="group__DataBoxGroup.html">DataBox</a> with all of the quantities needed for a CCE computation or component. The data structures represented by these tags should each have size <code>number_of_radial_points * Spectral::Swsh::number_of_swsh_collocation_points(l_max)</code>. All of these tags may be computed at once if using a <a class="el" href="group__DataBoxGroup.html">DataBox</a> using the template <code>mutate_all_precompute_cce_dependencies</code> or individually using the template specializations <code><a class="el" href="structCce_1_1PrecomputeCceDependencies.html" title="A set of procedures for computing the set of inputs to the CCE integrand computations that can be com...">PrecomputeCceDependencies</a></code>. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a2b18c2f467fe80ff7281445f4953f8a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b18c2f467fe80ff7281445f4953f8a6">&#9670;&nbsp;</a></span>cartesian_to_spherical_coordinates_and_jacobians()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cce::cartesian_to_spherical_coordinates_and_jacobians </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; *&gt;&#160;</td>
          <td class="paramname"><em>unit_cartesian_coords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; jacobian_tensor *&gt;&#160;</td>
          <td class="paramname"><em>cartesian_to_spherical_jacobian</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; inverse_jacobian_tensor *&gt;&#160;</td>
          <td class="paramname"><em>inverse_cartesian_to_spherical_jacobian</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cos_phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cos_theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>sin_phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>sin_theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>extraction_radius</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates both the Jacobian and inverse Jacobian between Cartesian and spherical coordinates, and the coordinates themselves. </p>
<h3>Details</h3>
<p>The <code>cartesian_to_spherical_jacobian</code> is \(dx^i/d\tilde{x}^{\tilde j}\), where the Cartesian components are in order \(x^i = \{x, y, z\}\) and the spherical coordinates are \(\tilde{x}^{\tilde j} = \{r, \theta, \phi\}\). The Cartesian coordinates given are the standard unit sphere coordinates:</p>
<p class="formulaDsp">
\begin{align*} x &amp;= \cos(\phi) \sin(\theta)\\ y &amp;= \sin(\phi) \sin(\theta)\\ z &amp;= \cos(\theta) \end{align*}
</p>
<dl class="section note"><dt>Note</dt><dd>These Jacobians are adjusted to improve regularity near the pole, in particular the \(\partial \phi / \partial x^i\) components have been scaled by \(\sin \theta\) (omitting a \(1/\sin(\theta)\)) and the \(\partial x^i/\partial \phi\) components have been scaled by \(1/\sin(\theta)\) (omitting a \(\sin(\theta)\)). The reason is that in most careful calculations, these problematic sin factors can actually be omitted because they cancel. In cases where they are actually required, they must be put in by hand. </dd></dl>

</div>
</div>
<a id="ac4badb01ac37f2d368a259ef85fb823e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4badb01ac37f2d368a259ef85fb823e">&#9670;&nbsp;</a></span>d_bondi_r()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cce::d_bondi_r </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::a&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; *&gt;&#160;</td>
          <td class="paramname"><em>d_bondi_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="structSpinWeighted.html">SpinWeighted</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 0 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>bondi_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dlambda_null_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>du_null_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::AA&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>inverse_null_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>l_max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the full 4-dimensional partial of the Bondi radius with respect to the intermediate null coordinates. </p>
<h3>Details</h3>
<p>The expression evaluated is obtained from differentiating the determinant equation for <code>bondi_r</code>, from (35) of <a class="el" href="citelist.html#CITEREF_Barkett2019uae">[3]</a> :</p>
<p class="formulaDsp">
\[ \partial_\alpha r = \frac{r}{4} \left(g^{A B} \partial_\alpha g_{A B} - \frac{\partial_\alpha \det q_{A B}}{\det q_{A B}}\right) \]
</p>
<p>Note that for the angular derivatives, we just numerically differentiate using the utilities in <code><a class="el" href="group__SpectralGroup.html#gaf2ce39b6bffcf7b2bbd66ac09f7e78b3" title="Evaluate the spin-weighted derivative DerivKind on the provided SpinWeighted&lt;ComplexDataVector, Spin&gt; collocation data, returning by value. ">Spectral::Swsh::angular_derivative()</a></code>. For the time and radial derivatives, the second term in the above equation vanishes. </p>

</div>
</div>
<a id="a518614109b0f0fdfe5082f8699343b07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a518614109b0f0fdfe5082f8699343b07">&#9670;&nbsp;</a></span>dlambda_null_metric_and_inverse()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cce::dlambda_null_metric_and_inverse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; *&gt;&#160;</td>
          <td class="paramname"><em>dlambda_null_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::AA&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; *&gt;&#160;</td>
          <td class="paramname"><em>dlambda_inverse_null_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::iA&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>angular_d_null_l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const jacobian_tensor &amp;&#160;</td>
          <td class="paramname"><em>cartesian_to_spherical_jacobian</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::iaa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>dt_spacetime_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::A&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>du_null_l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::AA&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>inverse_null_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::A&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>null_l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>spacetime_metric</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the partial derivative of the spacetime metric and inverse spacetime metric in the intermediate null radial coordinates with respect to the null generator \(l^\mu\). </p>
<h3>Details</h3>
<p>For full expressions of the \(l^\mu \partial_\mu g_{a b}\) and \(l^\mu \partial_\mu g^{a b}\) computed in this function, see equation (31) and (32) of <a class="el" href="citelist.html#CITEREF_Barkett2019uae">[3]</a>. Refer to <a class="el" href="citelist.html#CITEREF_Bishop1998uk">[8]</a> for more exposition about the overall construction of the coordinate transformations used for the intermediate null coordinates. </p>

</div>
</div>
<a id="aef6b36590b1996c6af1da396719c0a1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef6b36590b1996c6af1da396719c0a1d">&#9670;&nbsp;</a></span>dyads()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cce::dyads </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::i&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 2, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; *&gt;&#160;</td>
          <td class="paramname"><em>down_dyad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::I&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a>, 2, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; *&gt;&#160;</td>
          <td class="paramname"><em>up_dyad</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the complex angular dyads used to define the spin-weighted scalars in the CCE system. </p>
<h3>Details</h3>
<p>We use the typically chosen angular dyads in CCE <a class="el" href="citelist.html#CITEREF_Barkett2019uae">[3]</a> <a class="el" href="citelist.html#CITEREF_Bishop1997ik">[7]</a> :</p>
<p class="formulaDsp">
\begin{align*} q_A &amp;= \{-1, -i \sin(\theta)\}\\ q^A &amp;= \left\{-1, -i \frac{1}{\sin \theta}\right\} \end{align*}
</p>
<p>However, to maintain regularity and for compatibility with the more regular Jacobians from <code>Cce::cartesian_to_spherical_coordinates_and_jacobians()</code>, in the code we omit the factors of \(\sin \theta\) from the above equations. </p>

</div>
</div>
<a id="a246fe522bad41a8830e114c7d5e136e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a246fe522bad41a8830e114c7d5e136e3">&#9670;&nbsp;</a></span>logical_partial_directional_derivative_of_complex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cce::logical_partial_directional_derivative_of_complex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a> *&gt;&#160;</td>
          <td class="paramname"><em>d_u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComplexDataVector.html">ComplexDataVector</a> &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMesh.html">Mesh</a>&lt; 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dimension_to_differentiate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the partial derivative along a particular direction determined by the <code>dimension_to_differentiate</code>. The input <code>u</code> is differentiated with the spectral matrix and the solution is placed in <code>d_u</code>. </p>
<dl class="section note"><dt>Note</dt><dd>This is placed in <a class="el" href="namespaceCce.html" title="Contains functionality for Cauchy Characteristic Extraction. ">Cce</a> Utilities for its currently narrow use-case. If more general uses desire a single partial derivative of complex values, this should be moved to <code>NumericalAlgorithms</code>. This utility currently assumes the spatial dimensionality is 3, which would also need to be generalized, likely by creating a wrapping struct with partial template specializations. </dd></dl>

</div>
</div>
<a id="a0ea7655c4828aea4ec5a29941d709860"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ea7655c4828aea4ec5a29941d709860">&#9670;&nbsp;</a></span>mutate_all_pre_swsh_derivatives_for_tag()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BondiValueTag , typename DataBoxType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cce::mutate_all_pre_swsh_derivatives_for_tag </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; DataBoxType *&gt;&#160;</td>
          <td class="paramname"><em>box</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Evaluates the set of inputs to the CCE integrand for <code>BondiValueTag</code> that do not involve spin-weighted angular differentiation. </p>
<h3>Details</h3>
<p>This function is to be called on the <code>DataBox</code> holding the relevant CCE data on each hypersurface integration step, prior to evaluating the spin-weighted derivatives needed for the same CCE integrand. Provided a <code>DataBox</code> with the appropriate tags (including <code>all_pre_swsh_derivative_tags</code>, <code>all_swsh_derivative_tags</code> and <code><a class="el" href="structSpectral_1_1Swsh_1_1Tags_1_1LMax.html" title="Tag for the maximum spin-weighted spherical harmonic l; sets angular resolution. ">Spectral::Swsh::Tags::LMax</a></code>), this function will apply all of the necessary mutations to update <code>all_pre_swsh_derivatives_for_tag&lt;BondiValueTag&gt;</code> to their correct values for the current values for the remaining (input) tags. </p>

</div>
</div>
<a id="ad9aaac2c0f9818a9f6c9b1f311a373c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9aaac2c0f9818a9f6c9b1f311a373c5">&#9670;&nbsp;</a></span>mutate_all_precompute_cce_dependencies()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename &gt; class BoundaryPrefix, typename DataBoxType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cce::mutate_all_precompute_cce_dependencies </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; DataBoxType *&gt;&#160;</td>
          <td class="paramname"><em>box</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience routine for computing all of the CCE inputs to integrand computation that do not depend on intermediate integrand results. It should be executed before moving through the hierarchy of integrands. </p>
<h3>Details</h3>
<p>Provided a <a class="el" href="group__DataBoxGroup.html">DataBox</a> with the appropriate tags (including <code><a class="el" href="namespaceCce.html#aa00307a414eb1f569706cb7d7449fa4d" title="A typelist for the set of BoundaryValue tags needed as an input to any of the template specialization...">Cce::pre_computation_boundary_tags</a></code>, <code><a class="el" href="namespaceCce.html#a0a597e56873fee952fd464981a692bfb" title="A typelist for the set of tags computed by the set of template specializations of PrecomputeCceDepede...">Cce::pre_computation_tags</a></code>, <code><a class="el" href="structCce_1_1Tags_1_1BondiJ.html" title="Bondi parameter . ">Cce::Tags::BondiJ</a></code> and <code><a class="el" href="structSpectral_1_1Swsh_1_1Tags_1_1LMax.html" title="Tag for the maximum spin-weighted spherical harmonic l; sets angular resolution. ">Spectral::Swsh::Tags::LMax</a></code>), this function will apply all of the necessary mutations to update the <code><a class="el" href="namespaceCce.html#a0a597e56873fee952fd464981a692bfb" title="A typelist for the set of tags computed by the set of template specializations of PrecomputeCceDepede...">Cce::pre_computation_tags</a></code> to their correct values for the current values for the remaining (input) tags.</p>
<p>The <code>BoundaryPrefix</code> template template parameter is to be passed a prefix tag associated with the boundary value prefix used in the computation (e.g. <code><a class="el" href="structCce_1_1Tags_1_1BoundaryValue.html" title="A prefix tag representing the boundary data for a quantity on the extraction surface. ">Cce::Tags::BoundaryValue</a></code>), and allows easy switching between the regularity-preserving version and standard CCE. </p>

</div>
</div>
<a id="a710c185e2efce13bd57e2414145c2172"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a710c185e2efce13bd57e2414145c2172">&#9670;&nbsp;</a></span>mutate_all_swsh_derivatives_for_tag()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BondiValueTag , typename DataBoxTagList &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cce::mutate_all_swsh_derivatives_for_tag </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classdb_1_1DataBox.html">db::DataBox</a>&lt; DataBoxTagList &gt; *&gt;&#160;</td>
          <td class="paramname"><em>box</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This routine evaluates the set of inputs to the CCE integrand for <code>BondiValueTag</code> which are spin-weighted angular derivatives. </p>
<h3>Details</h3>
<p>This function is called on the <a class="el" href="group__DataBoxGroup.html">DataBox</a> holding the relevant CCE data during each hypersurface integration step, after evaluating <code><a class="el" href="namespaceCce.html#a0ea7655c4828aea4ec5a29941d709860" title="Evaluates the set of inputs to the CCE integrand for BondiValueTag that do not involve spin-weighted ...">mutate_all_pre_swsh_derivatives_for_tag()</a></code> with template argument <code>BondiValueTag</code> and before evaluating <code><a class="el" href="structCce_1_1ComputeBondiIntegrand.html" title="Computes one of the inputs for the integration of one of the Characteristic hypersurface equations...">ComputeBondiIntegrand</a>&lt;BondiValueTag&gt;</code>. Provided a <a class="el" href="group__DataBoxGroup.html">DataBox</a> with the appropriate tags (including <code><a class="el" href="namespaceCce.html#a8da977a43161ce3f5b046e3513724f54" title="A typelist for the full set of tags needed as direct or indirect input to any ComputeBondiIntegrand t...">Cce::all_pre_swsh_derivative_tags</a></code>, <code><a class="el" href="namespaceCce.html#ad3f639bb3b07cc123bdf53c26dbf0fff" title="A typelist for the set of tags computed by spin-weighted differentiation using utilities from the Sws...">Cce::all_swsh_derivative_tags</a></code>, <code><a class="el" href="namespaceCce.html#a9cbd52ad55ee87beb6abf5857c2db60a" title="A typelist for the full set of coefficient buffers needed to process all of the tags in all_swsh_deri...">Cce::all_transform_buffer_tags</a></code>, <code><a class="el" href="namespaceCce.html#a0a597e56873fee952fd464981a692bfb" title="A typelist for the set of tags computed by the set of template specializations of PrecomputeCceDepede...">Cce::pre_computation_tags</a></code>, and <code><a class="el" href="structSpectral_1_1Swsh_1_1Tags_1_1LMax.html" title="Tag for the maximum spin-weighted spherical harmonic l; sets angular resolution. ">Spectral::Swsh::Tags::LMax</a></code>), this function will apply all of the necessary mutations to update <code><a class="el" href="structCce_1_1single__swsh__derivative__tags__to__compute__for.html" title="A typelist for the set of tags computed by single spin-weighted differentiation using utilities from ...">Cce::single_swsh_derivative_tags_to_compute_for</a>&lt;BondiValueTag&gt;</code> and <code><a class="el" href="structCce_1_1second__swsh__derivative__tags__to__compute__for.html" title="A typelist for the set of tags computed by multiple spin-weighted differentiation using utilities fro...">Cce::second_swsh_derivative_tags_to_compute_for</a>&lt;BondiValueTag&gt;</code> to their correct values for the current values of the remaining (input) tags. </p>

</div>
</div>
<a id="a4b1e172af7db7136790d0adc298e41e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b1e172af7db7136790d0adc298e41e2">&#9670;&nbsp;</a></span>null_metric_and_derivative()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cce::null_metric_and_derivative </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; *&gt;&#160;</td>
          <td class="paramname"><em>du_null_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3, <a class="el" href="structCce_1_1Frame_1_1RadialNull.html">Frame::RadialNull</a> &gt; *&gt;&#160;</td>
          <td class="paramname"><em>null_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const jacobian_tensor &amp;&#160;</td>
          <td class="paramname"><em>cartesian_to_spherical_jacobian</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>dt_spacetime_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>spacetime_metric</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the spacetime metric and its first derivative in the intermediate radial null coordinates. </p>
<h3>Details</h3>
<p>These components are obtained by the steps in Section II-A of <a class="el" href="citelist.html#CITEREF_Barkett2019uae">[3]</a>, which is based on the computation from Section 4.3 of <a class="el" href="citelist.html#CITEREF_Bishop1998uk">[8]</a>. The most direct comparison is to be made with equation (31) of <a class="el" href="citelist.html#CITEREF_Barkett2019uae">[3]</a>, which gives the null metric components explicitly. The time derivative is then (using notation from equation (31) of <a class="el" href="citelist.html#CITEREF_Barkett2019uae">[3]</a>):</p>
<p class="formulaDsp">
\begin{align} \partial_{\bar u} g_{\bar u \bar \lambda} = \partial_{\bar u} g_{\bar \lambda \bar \lambda} = \partial_{\bar u} g_{\bar \lambda \bar A} &amp;= 0 \\ \partial_{\bar u} g_{\bar u \bar u} &amp;= \partial_{\breve t} g_{\breve t \breve t} \\ \partial_{\bar u} g_{\bar u \bar A} &amp;= \frac{\partial \breve x^{\breve i}}{\partial \bar x^{\bar A}}\\ g_{\breve i \breve t} \partial_{\bar u} g_{\bar A \bar B} &amp;= \frac{\partial \breve x^{\breve i}}{\partial \bar x^{\bar A}} \frac{\partial \breve x^{\breve j}}{\partial \bar x^{\bar B}} g_{\breve i \breve j} \end{align}
</p>
 
</div>
</div>
<a id="a9f0fbfceb7e1252112260c1d02a09961"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f0fbfceb7e1252112260c1d02a09961">&#9670;&nbsp;</a></span>null_vector_l_and_derivatives()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cce::null_vector_l_and_derivatives </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::A&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; *&gt;&#160;</td>
          <td class="paramname"><em>du_null_l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::A&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; *&gt;&#160;</td>
          <td class="paramname"><em>null_l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>dt_worldtube_normal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dt_lapse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>dt_spacetime_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>dt_shift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>lapse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>spacetime_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>shift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>worldtube_normal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the null 4-vector \(l^\mu\) on the worldtube surface that is to be used as the CCE hypersurface generator, and the first time derivative \(\partial_u l^\mu\). </p>
<h3>Details</h3>
<p>For mathematical description of our choice of the null generator, refer to equation (22) of <a class="el" href="citelist.html#CITEREF_Barkett2019uae">[3]</a>, and for the first time derivative see (25) of <a class="el" href="citelist.html#CITEREF_Barkett2019uae">[3]</a>. Refer to <a class="el" href="citelist.html#CITEREF_Bishop1998uk">[8]</a> for more exposition about the overall construction of the coordinate transformations used for the intermediate null coordinates. </p>

</div>
</div>
<a id="af367dfeb1f3ee40aca23c628e9809ac1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af367dfeb1f3ee40aca23c628e9809ac1">&#9670;&nbsp;</a></span>precomputed_cce_q_integrator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classMatrix.html">Matrix</a> &amp; Cce::precomputed_cce_q_integrator </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>number_of_radial_grid_points</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides access to a lazily cached integration matrix for the \(Q\) and \(W\) equations in CCE hypersurface evaluation. </p>
<h3>Details</h3>
<p>The provided matrix acts on the integrand collocation points and solves the equation,</p>
<p class="formulaDsp">
\[ (1 - y) \partial_y f + 2 f = g, \]
</p>
<p>for \(f\) given integrand \(g\). </p>

</div>
</div>
<a id="a8001cac388464a9afee45fe2787acb3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8001cac388464a9afee45fe2787acb3a">&#9670;&nbsp;</a></span>radial_integrate_cce_pole_equations()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cce::radial_integrate_cce_pole_equations </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="classComplexDataVector.html">ComplexDataVector</a> *&gt;&#160;</td>
          <td class="paramname"><em>integral_result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComplexDataVector.html">ComplexDataVector</a> &amp;&#160;</td>
          <td class="paramname"><em>pole_of_integrand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComplexDataVector.html">ComplexDataVector</a> &amp;&#160;</td>
          <td class="paramname"><em>regular_integrand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComplexDataVector.html">ComplexDataVector</a> &amp;&#160;</td>
          <td class="paramname"><em>boundary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComplexDataVector.html">ComplexDataVector</a> &amp;&#160;</td>
          <td class="paramname"><em>one_minus_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>l_max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>number_of_radial_points</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A utility function for evaluating the \(Q\) and \(W\) hypersurface integrals during CCE evolution. </p>
<h3>Details</h3>
<p>Computes and returns by <code>not_null</code> pointer the solution to the equation</p>
<p class="formulaDsp">
\[ (1 - y) \partial_y f + 2 f = A + (1 - y) B, \]
</p>
<p>where \(A\) is provided as <code>pole_of_integrand</code> and \(B\) is provided as <code>regular_integrand</code>. The value <code>one_minus_y</code> is required for determining the integrand and <code>l_max</code> is required to determine the shape of the spin-weighted spherical harmonic mesh. </p>

</div>
</div>
<a id="a87b43a20534ee24795c4b343c8045c39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87b43a20534ee24795c4b343c8045c39">&#9670;&nbsp;</a></span>trigonometric_functions_on_swsh_collocation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cce::trigonometric_functions_on_swsh_collocation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; *&gt;&#160;</td>
          <td class="paramname"><em>cos_phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; *&gt;&#160;</td>
          <td class="paramname"><em>cos_theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; *&gt;&#160;</td>
          <td class="paramname"><em>sin_phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; *&gt;&#160;</td>
          <td class="paramname"><em>sin_theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>l_max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs the collocation values for \(\cos(\phi)\), \(\cos(\theta)\), \(\sin(\phi)\), and \(\sin(\theta)\), returned by <code>not_null</code> pointer in that order. </p>
<h3>Details</h3>
<p>These are needed for coordinate transformations from the input Cartesian-like coordinates. </p>

</div>
</div>
<a id="a9c376c6944c906be71dafc0a37761a45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c376c6944c906be71dafc0a37761a45">&#9670;&nbsp;</a></span>worldtube_normal_and_derivatives()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cce::worldtube_normal_and_derivatives </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; *&gt;&#160;</td>
          <td class="paramname"><em>worldtube_normal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classgsl_1_1not__null.html">gsl::not_null</a>&lt; tnsr::I&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; *&gt;&#160;</td>
          <td class="paramname"><em>dt_worldtube_normal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cos_phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cos_theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>spacetime_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::aa&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>dt_spacetime_metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>sin_phi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__TensorGroup.html#ga06ebcb38a1f13c246e53378b9e8959ce">Scalar</a>&lt; <a class="el" href="classDataVector.html">DataVector</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>sin_theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tnsr::II&lt; <a class="el" href="classDataVector.html">DataVector</a>, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>inverse_spatial_metric</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the spatial unit normal vector \(s^i\) to the spherical worldtube surface and its first time derivative. </p>
<h3>Details</h3>
<p>Refer to equation (20) of <a class="el" href="citelist.html#CITEREF_Barkett2019uae">[3]</a> for the expression of the spatial unit normal vector, and equation (23) of <a class="el" href="citelist.html#CITEREF_Barkett2019uae">[3]</a> for the first time derivative. Refer to <a class="el" href="citelist.html#CITEREF_Bishop1998uk">[8]</a> for more exposition about the overall construction of the coordinate transformations used for the intermediate null coordinates. </p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.10-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
&copy; Copyright 2017 - 2019
<a href="https://black-holes.org">SXS Collaboration</a>,
<a href="LICENSE.txt" target="_blank">
<span class="hidden-xs">Distributed under the</span>
MIT License</a>
</small></address>
</body>
</html>
